# 概述
## 微服务特点：
> ### 单一职责：
> > 微服务架构中的每个服务具有独自的业务逻辑  
> > 是符合高内聚、低耦合以及单一职责原则的单元  
> > 不同服务间通过管道方式灵活组合，从而构建庞大系统  
> ### 轻量级通信：
> > 服务之间通过轻量级的通信机制实现互联互通  
> > 所谓轻量，是指语言无关、平台无关的交互方式  
> ### 独立性：
> > 每个服务在应用交付过程中，独立地开发、测试、部署  
> ### 进程隔离：
> > 应用程序由多个服务组成，每个服务都是高度自治的独立业务实体  
> > 可以运行在独立的进程中  
> > 不同服务能非常容易的部署到不同的主机上  
---
## 单体架构缺点：
> ### 复杂性逐渐提高：
> > 代码越来越多，各模块区别模糊  
> > 人员流动会造成不易发现的坑
> ### 维护成本大：
> > 团队沟通成本越来越大  
> > 引发bug的原因越来越多，不好排查  
> ### 持续交付周期长：
> > 构建和部署的时间会随功能的增多而增加  
> > 任何细节的修改都会触发部署流水线  
> ### 技术选型成本高、扩展性差：
> > 单体架构倾向于采用统一的技术平台或方案解决所有问题  
> > 若后期想引入新技术或框架，成本和风险都很大  
---
## 微服务架构缺点：
> ### 运维要求高：
> > 由于项目是由多个微服务构成  
> > 每个模块出现问题都会造成整个项目运行异常
> > 这就对运维人员提出了很高的要求
> ### 分布式的复杂性：
> > 对于单体架构来讲，我们可以不使用分布式  
> > 但对于微服务来说，分布式几乎是必会的技术  
> > 由于分布式本身的复杂性，导致微服务架构也变得复杂起来  
> ### 接口调整成本高：
> > 一旦某微服务接口发生较大变动  
> > 那么所有依赖它的微服务都要做相应的调整  
> > 由于微服务非常多，那么调整接口所造成的成本将会明显提高  
> ### 重复劳动：
> > 单体应用里，对于共同使用的业务可以抽象为一个工具类  
> > 以供所有模块共同使用  
> > 但对于微服务，一个微服务的工具类不能被其他微服务直接调用  
> > 这就需要在每个微服务上都构建这样一个工具类，从而导致了代码重复  
---

.  
# 微服务开发需要的组件：
## protobuf:
> ### 简介：
> > 跨语言、跨平台的数据格式  
> > 很适合用作数据存储和作为不同应用不同语言之间的通信的数据交换格式  
> ### 优点：
> > 更小，更简单，解析速度更快  
> > 只需使用Protobuf对数据结构进行一次描述，  
> > 即可利用各种语言或从各种不同数据流中对你的结构化数据轻松读写  
> > 使用Protobuf无需学习复杂的文档对象模型，简单易学  
> ### 缺点：
> > 功能简单，无法用来表示复杂的概念  
> > 相比xml，在通用性上差很多  
> > 不适合对基于文本的标记文档(如HTML)建模  
> > 以二进制形式存储，除非有.proto定义，否则无法读出其内容  
> ### Protobuf安装：
> 1. 下载：  
> git clone https://github.com/protocolbuffers/protobuf.git
> 2. 安装依赖库：  
> sudo apt install autoconf automake libtool curl make g++ unzip libffi-dev -y
> 3. 检查环境和文件：  
> cd protobuf  
> ./autogen.sh  
> ./configure  
> 4. 编译：  
> make
> 5. 安装：  
> sudo make install  
> sudo ldconfig     // 刷新共享库(不然重启才可以使用)
> 6. 测试是否安装成功：
> protoc -h
> ### 使用ProtoBuf：
> 1. 创建.proto文件，定义数据结构  
> 2. 编译.proto文件，生成读写接口
> 3. 调用接口实现序列化、反序列化以及读写
> ### 基本语法：
> ```proto
> syntax = "proto3"     // 声明版本
> ```
## gRPC：
> 通讯协议  
## consul:
> 调度管理、服务发现  
## micro:
> 微服务框架  
## docker：
> 部署  