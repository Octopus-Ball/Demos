// Code generated by protoc-gen-go. DO NOT EDIT.
// source: user.proto

// 指定包名

package proto

import (
	context "context"
	fmt "fmt"
	"io"
	math "math"

	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	// codes "google.golang.org/grpc/codes"
	// status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// 请求消息
type NumRequest struct {
	N                    int32    `protobuf:"varint,1,opt,name=n,proto3" json:"n,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NumRequest) Reset()         { *m = NumRequest{} }
func (m *NumRequest) String() string { return proto.CompactTextString(m) }
func (*NumRequest) ProtoMessage()    {}
func (*NumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_116e343673f7ffaf, []int{0}
}

func (m *NumRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NumRequest.Unmarshal(m, b)
}
func (m *NumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NumRequest.Marshal(b, m, deterministic)
}
func (m *NumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumRequest.Merge(m, src)
}
func (m *NumRequest) XXX_Size() int {
	return xxx_messageInfo_NumRequest.Size(m)
}
func (m *NumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NumRequest proto.InternalMessageInfo

func (m *NumRequest) GetN() int32 {
	if m != nil {
		return m.N
	}
	return 0
}

// 响应消息
type NumResponse struct {
	N                    int32    `protobuf:"varint,1,opt,name=n,proto3" json:"n,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NumResponse) Reset()         { *m = NumResponse{} }
func (m *NumResponse) String() string { return proto.CompactTextString(m) }
func (*NumResponse) ProtoMessage()    {}
func (*NumResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_116e343673f7ffaf, []int{1}
}

func (m *NumResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NumResponse.Unmarshal(m, b)
}
func (m *NumResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NumResponse.Marshal(b, m, deterministic)
}
func (m *NumResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumResponse.Merge(m, src)
}
func (m *NumResponse) XXX_Size() int {
	return xxx_messageInfo_NumResponse.Size(m)
}
func (m *NumResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NumResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NumResponse proto.InternalMessageInfo

func (m *NumResponse) GetN() int32 {
	if m != nil {
		return m.N
	}
	return 0
}

func init() {
	proto.RegisterType((*NumRequest)(nil), "proto.NumRequest")
	proto.RegisterType((*NumResponse)(nil), "proto.NumResponse")
}

func init() {
	proto.RegisterFile("user.proto", fileDescriptor_116e343673f7ffaf)
}

var fileDescriptor_116e343673f7ffaf = []byte{
	// 164 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2a, 0x2d, 0x4e, 0x2d,
	0xd2, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x05, 0x53, 0x4a, 0x52, 0x5c, 0x5c, 0x7e, 0xa5,
	0xb9, 0x41, 0xa9, 0x85, 0xa5, 0xa9, 0xc5, 0x25, 0x42, 0x3c, 0x5c, 0x8c, 0x79, 0x12, 0x8c, 0x0a,
	0x8c, 0x1a, 0xac, 0x41, 0x8c, 0x79, 0x4a, 0xd2, 0x5c, 0xdc, 0x60, 0xb9, 0xe2, 0x82, 0xfc, 0xbc,
	0xe2, 0x54, 0x54, 0x49, 0xa3, 0x97, 0x8c, 0x5c, 0xfc, 0xa1, 0xc5, 0xa9, 0x45, 0x9e, 0x79, 0x69,
	0xf9, 0xc1, 0xa9, 0x45, 0x65, 0x99, 0xc9, 0xa9, 0x42, 0x86, 0x5c, 0x6c, 0xee, 0xa9, 0x25, 0x7e,
	0xa5, 0xb9, 0x42, 0x82, 0x10, 0x5b, 0xf4, 0x10, 0x66, 0x4b, 0x09, 0x21, 0x0b, 0x41, 0x8c, 0x54,
	0x62, 0x10, 0x32, 0xe1, 0x62, 0x87, 0x68, 0x29, 0x26, 0x5a, 0x8f, 0x01, 0x23, 0x48, 0x57, 0x40,
	0x29, 0x69, 0xba, 0x34, 0x18, 0x85, 0xcc, 0xb9, 0x38, 0x7c, 0xf2, 0xf3, 0x0b, 0x48, 0xd4, 0x66,
	0xc0, 0x98, 0xc4, 0x06, 0x96, 0x30, 0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0x06, 0x9c, 0xcf, 0x81,
	0x40, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// UserInfoServiceClient is the client API for UserInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UserInfoServiceClient interface {
	// 定义方法
	// 单一请求，单一应答
	GetNum(ctx context.Context, in *NumRequest, opts ...grpc.CallOption) (*NumResponse, error)
	// 服务端流式应答(可用于下载)
	GetNums(ctx context.Context, in *NumRequest, opts ...grpc.CallOption) (UserInfoService_GetNumsClient, error)
	// 客户端流式请求(可用于上传)
	PutNums(ctx context.Context, opts ...grpc.CallOption) (UserInfoService_PutNumsClient, error)
	// 双向流式请求应答
	LoopNums(ctx context.Context, opts ...grpc.CallOption) (UserInfoService_LoopNumsClient, error)
}

type userInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserInfoServiceClient(cc grpc.ClientConnInterface) UserInfoServiceClient {
	return &userInfoServiceClient{cc}
}

func (c *userInfoServiceClient) GetNum(ctx context.Context, in *NumRequest, opts ...grpc.CallOption) (*NumResponse, error) {
	out := new(NumResponse)
	err := c.cc.Invoke(ctx, "/proto.UserInfoService/GetNum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userInfoServiceClient) GetNums(ctx context.Context, in *NumRequest, opts ...grpc.CallOption) (UserInfoService_GetNumsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UserInfoService_serviceDesc.Streams[0], "/proto.UserInfoService/GetNums", opts...)
	if err != nil {
		return nil, err
	}
	x := &userInfoServiceGetNumsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserInfoService_GetNumsClient interface {
	Recv() (*NumResponse, error)
	grpc.ClientStream
}

type userInfoServiceGetNumsClient struct {
	grpc.ClientStream
}

func (x *userInfoServiceGetNumsClient) Recv() (*NumResponse, error) {
	m := new(NumResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userInfoServiceClient) PutNums(ctx context.Context, opts ...grpc.CallOption) (UserInfoService_PutNumsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UserInfoService_serviceDesc.Streams[1], "/proto.UserInfoService/PutNums", opts...)
	if err != nil {
		return nil, err
	}
	x := &userInfoServicePutNumsClient{stream}
	return x, nil
}

type UserInfoService_PutNumsClient interface {
	Send(*NumRequest) error
	CloseAndRecv() (*NumResponse, error)
	grpc.ClientStream
}

type userInfoServicePutNumsClient struct {
	grpc.ClientStream
}

func (x *userInfoServicePutNumsClient) Send(m *NumRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *userInfoServicePutNumsClient) CloseAndRecv() (*NumResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(NumResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userInfoServiceClient) LoopNums(ctx context.Context, opts ...grpc.CallOption) (UserInfoService_LoopNumsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UserInfoService_serviceDesc.Streams[2], "/proto.UserInfoService/LoopNums", opts...)
	if err != nil {
		return nil, err
	}
	x := &userInfoServiceLoopNumsClient{stream}
	return x, nil
}

type UserInfoService_LoopNumsClient interface {
	Send(*NumRequest) error
	Recv() (*NumResponse, error)
	grpc.ClientStream
}

type userInfoServiceLoopNumsClient struct {
	grpc.ClientStream
}

func (x *userInfoServiceLoopNumsClient) Send(m *NumRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *userInfoServiceLoopNumsClient) Recv() (*NumResponse, error) {
	m := new(NumResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UserInfoServiceServer is the server API for UserInfoService service.
type UserInfoServiceServer interface {
	// 定义方法
	// 单一请求，单一应答
	GetNum(context.Context, *NumRequest) (*NumResponse, error)
	// 服务端流式应答(可用于下载)
	GetNums(*NumRequest, UserInfoService_GetNumsServer) error
	// 客户端流式请求(可用于上传)
	PutNums(UserInfoService_PutNumsServer) error
	// 双向流式请求应答
	LoopNums(UserInfoService_LoopNumsServer) error
}

// UnimplementedUserInfoServiceServer can be embedded to have forward compatible implementations.
type UnimplementedUserInfoServiceServer struct {
}

func (*UnimplementedUserInfoServiceServer) GetNum(ctx context.Context, req *NumRequest) (*NumResponse, error) {
	fmt.Printf("GetNum：%d\n", req.N)
	return &NumResponse{N: req.N}, nil
	// return nil, status.Errorf(codes.Unimplemented, "method GetNum not implemented")
}
func (*UnimplementedUserInfoServiceServer) GetNums(req *NumRequest, srv UserInfoService_GetNumsServer) error {
	fmt.Printf("GetNums：%d\n", req.N)
	for i := 0; i < int(req.N); i++ {
		srv.Send(&NumResponse{N: int32(i)})
	}
	return nil
	// return status.Errorf(codes.Unimplemented, "method GetNums not implemented")
}
func (*UnimplementedUserInfoServiceServer) PutNums(srv UserInfoService_PutNumsServer) error {
	sum := 0
	for {
		req, err := srv.Recv()
		if err != nil {
			if err == io.EOF {
				fmt.Printf("请求数据传输完毕")
				return srv.SendAndClose(&NumResponse{N: int32(sum)})
			} else {
				fmt.Printf("接收错误: %v\n", err)
			}
		}
		fmt.Printf("PutNums: %d\n", req.N)
		sum++
	}
	// return status.Errorf(codes.Unimplemented, "method PutNums not implemented")
}
func (*UnimplementedUserInfoServiceServer) LoopNums(srv UserInfoService_LoopNumsServer) error {
	for {
		req, err := srv.Recv()
		fmt.Printf("LoopNums: %d\n", req.N)
		if err != nil {
			if err == io.EOF {
				return nil
			} else {
				return err
			}
		}
		err = srv.Send(&NumResponse{N: req.N})
		if err != nil {
			return err
		}
	}
	// return status.Errorf(codes.Unimplemented, "method LoopNums not implemented")
}

func RegisterUserInfoServiceServer(s *grpc.Server, srv UserInfoServiceServer) {
	s.RegisterService(&_UserInfoService_serviceDesc, srv)
}

func _UserInfoService_GetNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserInfoServiceServer).GetNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.UserInfoService/GetNum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserInfoServiceServer).GetNum(ctx, req.(*NumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserInfoService_GetNums_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NumRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserInfoServiceServer).GetNums(m, &userInfoServiceGetNumsServer{stream})
}

type UserInfoService_GetNumsServer interface {
	Send(*NumResponse) error
	grpc.ServerStream
}

type userInfoServiceGetNumsServer struct {
	grpc.ServerStream
}

func (x *userInfoServiceGetNumsServer) Send(m *NumResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UserInfoService_PutNums_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UserInfoServiceServer).PutNums(&userInfoServicePutNumsServer{stream})
}

type UserInfoService_PutNumsServer interface {
	SendAndClose(*NumResponse) error
	Recv() (*NumRequest, error)
	grpc.ServerStream
}

type userInfoServicePutNumsServer struct {
	grpc.ServerStream
}

func (x *userInfoServicePutNumsServer) SendAndClose(m *NumResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *userInfoServicePutNumsServer) Recv() (*NumRequest, error) {
	m := new(NumRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _UserInfoService_LoopNums_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UserInfoServiceServer).LoopNums(&userInfoServiceLoopNumsServer{stream})
}

type UserInfoService_LoopNumsServer interface {
	Send(*NumResponse) error
	Recv() (*NumRequest, error)
	grpc.ServerStream
}

type userInfoServiceLoopNumsServer struct {
	grpc.ServerStream
}

func (x *userInfoServiceLoopNumsServer) Send(m *NumResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *userInfoServiceLoopNumsServer) Recv() (*NumRequest, error) {
	m := new(NumRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _UserInfoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.UserInfoService",
	HandlerType: (*UserInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNum",
			Handler:    _UserInfoService_GetNum_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetNums",
			Handler:       _UserInfoService_GetNums_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PutNums",
			Handler:       _UserInfoService_PutNums_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "LoopNums",
			Handler:       _UserInfoService_LoopNums_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "user.proto",
}
