# 概述
## 微服务特点：
> ### 单一职责：
> > 微服务架构中的每个服务具有独自的业务逻辑  
> > 是符合高内聚、低耦合以及单一职责原则的单元  
> > 不同服务间通过管道方式灵活组合，从而构建庞大系统  
> ### 轻量级通信：
> > 服务之间通过轻量级的通信机制实现互联互通  
> > 所谓轻量，是指语言无关、平台无关的交互方式  
> ### 独立性：
> > 每个服务在应用交付过程中，独立地开发、测试、部署  
> ### 进程隔离：
> > 应用程序由多个服务组成，每个服务都是高度自治的独立业务实体  
> > 可以运行在独立的进程中  
> > 不同服务能非常容易的部署到不同的主机上  
---
.  
## 单体架构缺点：
> ### 复杂性逐渐提高：
> > 代码越来越多，各模块区别模糊  
> > 人员流动会造成不易发现的坑
> ### 维护成本大：
> > 团队沟通成本越来越大  
> > 引发bug的原因越来越多，不好排查  
> ### 持续交付周期长：
> > 构建和部署的时间会随功能的增多而增加  
> > 任何细节的修改都会触发部署流水线  
> ### 技术选型成本高、扩展性差：
> > 单体架构倾向于采用统一的技术平台或方案解决所有问题  
> > 若后期想引入新技术或框架，成本和风险都很大  
---
.  
## 微服务架构缺点：
> ### 运维要求高：
> > 由于项目是由多个微服务构成  
> > 每个模块出现问题都会造成整个项目运行异常
> > 这就对运维人员提出了很高的要求
> ### 分布式的复杂性：
> > 对于单体架构来讲，我们可以不使用分布式  
> > 但对于微服务来说，分布式几乎是必会的技术  
> > 由于分布式本身的复杂性，导致微服务架构也变得复杂起来  
> ### 接口调整成本高：
> > 一旦某微服务接口发生较大变动  
> > 那么所有依赖它的微服务都要做相应的调整  
> > 由于微服务非常多，那么调整接口所造成的成本将会明显提高  
> ### 重复劳动：
> > 单体应用里，对于共同使用的业务可以抽象为一个工具类  
> > 以供所有模块共同使用  
> > 但对于微服务，一个微服务的工具类不能被其他微服务直接调用  
> > 这就需要在每个微服务上都构建这样一个工具类，从而导致了代码重复  
---

.  
# 微服务需要考虑的问题：
## 1.微服务如何通信：
> ### 从通信模式考虑：
> > ||一对一|一对多|
> > |:---:|:---:|:---:|
> > |同步|最常见||
> > |异步|通知-请求异步响应|发布订阅-发布异步响应|
> ### 从通信协议考虑：
> 微服务架构下，数据交互一般是  
> 对内RPC，对外REST  
## 服务发现问题：
> ### 简洁：
> > 微服务发现有2种方式(客户端发现、服务端发现)
> ### 客户端服务发现：
> > 1.微服务启动后将自身信息(ip、端口等)注册到注册中心  
> > 2.客户端先访问注册中心，获取服务端信息  
> > 3.客户端利用获取的信息，再通过负载均衡，就可以去访问微服务了  
> ### 服务端服务发现：
> > 客户端访问时，不用去注册中心了  
> > 可用通过服务发现代理去直接访问  
## 微服务如何部署、更新、扩容:
> > 微服务部署到 docker容器  
> > 涉及容器编排工具，如k8s
---

.  
# 微服务开发需要的组件：
1. ## Protobuf:  
   跨语言、跨平台的数据格式  
   很适合用作数据存储和作为不同应用不同语言之间的通信的数据交换格式
2. ## gRPC:  
   通讯协议
3. ## consul:  
   调度管理、服务发现
4. ## micro:  
   微服务框架
5. ## docker:  
   部署