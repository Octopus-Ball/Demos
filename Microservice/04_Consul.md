# 服务注册与发现：
## 为什么需要服务注册与发现：
> 微服务系统由很多个单一职责的服务单元组成  
> 而每个微服务又有众多实例，服务之间的相互依赖成网状  
> 如果一一对应的进行管理会很繁琐 
> 所以该系统需要服务注册中心来统一管理微服务案例  
> 方便查看每一个微服务实例的健康状态  
## 服务注册：
> 服务注册是指向服务注册中心注册一个服务实例  
> 服务提供者将自己的服务信息(服务名、IP地址等)告知服务注册中心  
## 服务发现：
> 当服务消费者需要消费一个服务时  
> 服务注册中心能够告知消费者它所要消费的实例信息
> 一般情况下一个服务既是服务提供者也是服务消费者  
> 服务消费者一般使用HTTP协议或消息组件来进行服务消费  
---

# Consul：
> ## 常用服务发现框架：
> zookeeper、eureka、etcd、consul
> ## Consul简介：
> consul是提供服务发现的工具  
> Consul是分布式的、高可用的、可横向扩展的  
> ## 关键特性：
> ### 服务发现(service discovery):
> > consul通过DNS或者HTTP接口使服务注册和发现变得很容易  
> > 一些外部服务，例如saas提供的也可以一样注册  
> ### 健康检测(health checking):
> > 健康检测使consul可以快速的告警在集群中的操作  
> > 可以防止服务转发到故障的服务上面  
> ### key/value storage:
> > 一个用来存储动态配置的系统，提供简单的HTTP接口  
> > 可以在任何地方操作  
> ### 多数据中心(multi-datacenter):
> > 无需复杂的配置即可支持任意数量的区域  
> ## 集群架构：
> 1. Consul集群由运行consul Agent的节点组成,Agent可运行为server或client模式  
> 2. Consul中有Server和Client两种角色  
> 3. Server用于维护集群的状态信息，保存配置信息，实现数据一致性，响应RPC请求  
> 4. 每个数据中心必须至少有一台Server，官方建议至少运行3个或三个以上Server，其他agent运行为Client模式  
> 5. 多个Server之间需要选举一个leader(该选举过程基于Raft协议实现)  
> 6. ServerLeader负责同步注册信息给其他Server，同时也要负责各个Consul节点的健康检测  
> 7. 多个Server节点上的Consul数据信息保持强一致性  
> 8. Server节点之间的数据一致性保证协议使用的是raft协议
> 9. Client，无状态，将HTTP和DNS接口请求转发给Server,所有注册到当前节点的服务会被转发到Server  
> 10. Consul支持多数据中心，每个数据中心都要安装一组Consul集群  
> 多数据中心间基于gossip protocol协议来通讯，使用Raft算法实现一致性  
> ## 运行consul agent的命令及参数：
> ```shell
> consul agent -xx ...
>   # 相关参数
>   -server: 定义agent运行在server模式
>   -bootstrap-expect: 在一个数据中心中期望提供的server节点数目
>                       consul一直等达到指定server数目时才会引导整个集群
>   -data-dir: 提供一个目录用来存放agent的状态(该目录需要稳定，系统重启都继续存在)
>   -node：节点在集群中的名字(需要是唯一的，默认是该节点的主机名)
>   -bind：该地址用来在集群内部通信(默认0.0.0.0)
>   -ui：启动web界面
>   -config-dir：配置文件目录(里面所有.json文件都会被加载)
>   -rejoin：使consul忽略先前的离开，再次启动后仍尝试加入集群中
>   -client：consul服务侦听地址，该地址提供HTTP、DNSRPC等服务
>               (默认是127.0.0.1，若需要对外提供服务，需改成0.0.0.0)
> ```
---

# 往consul注册服务：
## 简介：
> 搭建号consul集群后，用户或程序就可到consul中注册或查询服务  
> consul支持两种方式实现服务注册  
> 一种是是通过HTTP形式的服务注册API  
> 另一种是通过json格式的配置文件实现注册
> (官方推荐使用配置文件)   







# Raft算法：
## 番外：
> 分布式系统在极大提高可用性、容错性的同时，带来了一致性问题(CAP理论)  
> Raft算法能够解决分布式系统环境下的一致性问题  
> Etcd和Consul都采取了这个算法  
## 简介：
> 实现分布式共识的协议  
> Raft是用于管理复制日志的一致性算法  
> 也为构建实用系统提供了更好的基础  
## Raft集群：
> Raft集群包含多个服务器，能够容忍不超过半数的服务器故障  
> 每个服务器都处于以下三个状态之一，这几个状态可以互相转换  
> `Leader：处理所有客户端交互，日志复制等，一般一次只有一个Leader`  
> `Follower：类似选民，完全被动`  
> `Candidate：可参与领导选举的人`  
## 选举Leader过程：
> Raft使用`心跳机制`来触发领导选举  
> 当服务器启动初时，所有的节点都是Follower角色  
> 并且所有节点被赋予一个150ms~300ms的时延  
> 当某个节点的时延到达以后，其角色转为Candidate  
> Candidate开始向其他节点发送拉票信息，(并自己先投自己一票)  
> 当该Candidate获得大多数选票以后就会变为Leader  
> Leader会不停的给他的选民发送心跳消息










# CAP原则：
> ## 简介：
> > CAP原则是分布式架构中的一个基本原则  
> > CAP原则是指在一个分布式系统中的  
> > 一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)三者不可兼得  
> ## 一致性(C):
> > 在分布式系统中的所有数据备份，在同一时刻是否是同样的值  
> ## 可用性(A):
> > 在集群一部分故障后，集群整体是否还能提供服务  
> > 可用性一般使用负载均衡或心跳检测+IP漂移来保证  
> ## 分区容忍性(P):
> > 系统能够容忍节点之间的网络通信的故障  
> > 也就是说单台服务器或多台服务器出现网络问题后，其他服务依然能正常提供服务  
> > 分区容错性可以使用选举机制来实现  
> ## 精髓：
> > CAP原则的精髓就是要么AP要么CP要么AC，但不存在CAP  
> > 因此在进行分布式架构设计时，必须做出取舍  
> > 通常情况下我们会选择满足可用性(A)和分区容错性(P)，而牺牲掉一致性  
> > 因为若不能保证可用性与分区容错性那么这个分布式系统就失去意义  
---

# BASE理论：
> ## 简介：consistent
> 基本可用BA(Basically Available)  
> 软状态(Soft state)
> 最终一致性(Eventually consistent)
> ## 为什么会出现BASE理论：
> CAP原则表明，对于一个分布式系统而言，无法同时满足  
> Consistency(强一致性)、Availability(可用性)、Partition tolerance(分区容忍性)  
> 这三个条件，最多只能满足其中两个  
> 由于我们三个都无法抛弃，但CAP原则限制了我们  
> 我们选择尽量靠近CAP定理，在此大势所趋下，出现了BSSE定理  
> ## 核心思想：
> 强一致性无法得到保障时  
> 我们可用根据业务自身的特点，采用适当的方式来达到最终一致性  
---

# 事务：
## 简介：
> 事务是由一个或多个sql语句组成的单元  
> 每个sql语句互相依赖，作为一个不可分割的整体  
> 若该单元中的某条sql语句执行失败，那么整个单元将回滚  
> 只有单元中所有sql语句均执行成功，事务才会被顺利执行  
## 事务特性：
> 1. 原子性  
> 一个事务不可再分割，要么都执行，要么都不执行  
> 2. 一致性：  
> 一个事务执行会使数据从一个一致状态切换到另一个一致状态  
> 3. 隔离性：  
> 一个事务的执行不受其他事务的干扰  
> 4. 持久性：  
> 一个事务一旦提交，则会永久的改变数据库数据  
## 分布式事务：
> 分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器  
> 分别位于不同的分布式系统的不同节点上  
> 简单说就是一次大操作由不同小操作组成，这些小操作分布在不同的服务器上，且属于不同应用  
> 分布式事务需要保证这些小操作要么全部成功要么全部失败  
> 本质上来说，分布式事务就是为了保证不同数据库的数据一致性  











