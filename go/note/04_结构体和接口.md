# 结构体：
> ## 简介：
> 结构体是类型中带有成员的复合类型  
> Go语言使用结构体和结构体成员来描述真实世界的实体和对应属性
> ## 结构体字段特性:
> 1. 字段拥有自己的类型和值
> 2. 字段名必须唯一
> 3. 字段的类型也可以是结构体，甚至字段所在结构体的类型
> ## 定义结构体：
> ```go
> type 自定义类型名 struct {
>   字段1 字段1类型
>   字段2 字段2类型
> }
> ```
> ## 结构体实例化：
> > 结构体实例化是根据结构体定义的格式创建一份与格式一致的内存区域
> ```go
> type Student struct{
>   name string
>   age int
> }
>
> // 方式1(使用键值对初始化结构体实例)
> s1 := Student{name: "zz", age: 1}
>
> // 方式2(初始化省略键)
> // 该方法必须初始化所有字段，且初始化字段顺序要与结构体中的声明顺序一致
> s2 := Student{"aa", 8}
>
> // 方式3
> var s3 Student
> s3.age = 5
> s3.name = "zy"
>
> // 方式4
> s4 := new(Student)    // s3是一个指针
> s4.name = "yy"
> s4.age = 2
>
> // 方式5(工厂模式实例化)
> // go中struct没有构造函数，一般可用构造函数来解决该问题
> // 这类工厂函数的函数名一般以new开头
> // 当结构体比较大时，尽量返回指针(因为go函数返回是值传递)
> func newStudent(name string, age int) *Student {
>   return &Student{
>       name,
>       age,
>   }
> }
>
> fmt.Println(s1, s2, s3, s4)
> ```
> ## 番外：
> > 在C/C++语言中，使用指针访问结构体字段需要用 -> 操作符  
> > Go语言中直接用 . 就可以
> ## 匿名结构体：
> ```go
> // 多用于临时需要一个结构体
> var t struct {    // 实例化t为一个结构体类型
>   x int
>   y int
> }
> t.x = 10
> t.y = 5
> ```
> ## 注意：
> 1. 结构体是用户单独定义的类型，不能和其他类型进行强制转换
> 2. 结构体可以包含其他结构体
> 3. 结构体不可以包含自身，但可以包含自身结构体的指针
> ## 给结构体绑定方法：
> > ### 简介：
> > 方法是作用于特定类型的函数(限定那个类型可以调用)  
> > 将函数绑定到具体的类型中，则称该函数是该类型的方法
> > ### 接收者:
> > 类似于python里的self，js里的this  
> > 接收者表示的是调用该方法的具体类型变量(多用类型的首字母小写来表示)  
> > ### 定义及使用方法：
> ```go
> // 定义方法
> //    接收者     方法名   参数
> func (s *Student)setName(name string) {
>   s.name = name
> }
> // 因为结构体是值传递，所以接收者应该是指针类型
> // 否则接收器只是调用者的一个副本
> 
> // 使用方法
> s := Student{"zy", 5}
> s.setName("yy")
> ```
> ## 字段可见性：
> > 若结构体内的字段首字母是小写的，那么该字段在包外不可见  
> > 因此在其他包中无法为这些字段赋值(会引发panic错误)
> > 因此，若想在一个包中访问另一个包的结构体中的字段，这些字段首字母必须大写
> ## 组合结构体：
> > ### 简介：
> > 1. 一个结构体里嵌套另一个结构体  
> > 2. go中没有继承的概念，匿名嵌套实现了类似于继承的效果
> ```go
> // 具名嵌套
> type person struct {
>   Name string
> }
> type student struct {
>   p person
>   score int
> }
> s := new(student)
> s.p.Name = "zy"
> s.score = 20
>
>
> // 匿名嵌套
> type student struct {
>   person
>   score int
> }
> s := new(student)
> s.Name = "zy"
> s.score = 20
> // 若student重写了person的字段或方法，那么直接 . 的是重写后的
> // 若想访问person的，则需要 .person.Name
> // 若继承的多个父结构体里又相同字段，就不能用 . 去访问
> // 需要 . 父结构体名.字段
> ```
---

.  
# 接口：
> ## 简介：
> 1. 接口是一种类型
> 2. 它声明了一个或多个方法签名，任何实现了这些方法的类型，都称为实现了该接口
> 3. Go面向对象的灵活性很大一部分原因在于接口的存在
> 4. Go通过interface实现了其他面向对象语言的多态的概念
> ## 应用场景：
> > 不关心一个变量是什么类型，只关心能调用它的什么方法
> ## 接口与类型的关系：
> 1. 接口指定类型应该具有的方法
> 2. 类型决定如何实现这些方法
> 3. 当一个类型实现了接口中的所有方法时，称为该类型实现了该接口
> 4. 同一个结构体可以实现多个接口
> 5. 接口可以存储任何实现了该接口的类型
> ## 值接收者实现接口与指针接收者实现接口：
> 1. 使用值接收者实现接口的方法，结构体类型和其指针类型都能存
> 2. 使用指针接收者实现接口的方法，只能存结构体指针类型的变量
> ## 定义接口:
> ```go
> // 定义接口
> type 接口名 interface{
>   方法名1(参数类型1, 参数类型2 ...)(返回值类型1, 返回值类型2 ...)
>   方法名2(参数类型1, 参数类型2 ...)(返回值类型1, 返回值类型2 ...)
> }
> ```
> ## 空接口：
> > ### 简介:
> > 没有定义任何方法的接口  
> > 任何类型都实现了空接口
> > 空接口类型的变量可以存储任意类型的变量
> > ### 定义：
> ```go
> // 空接口一般没必要起名字
> interface{}
> ```
> > ### 空接口的应用：
> ```go
> // 空接口作为函数的参数
> func funcName(a interface{}) {
> 
> }
>
> // 空接口作为map的值(这样该map就可以保存任意值)
> var myMap = make(map[string]interface{})
> ```
> ## 接口嵌套：
> > 一个接口可以包含另一个或多个其他接口  
> > 这相当于直接将这些内嵌接口的方法列举在外层接口中一样
> ```go
> type ReadWrite interface {
>   Read(b Buffer) bool
>   Write(b Buffer) bool
>}
>
>type Lock interface {
>   Lock()
>   Unlock()
>}
>
>type File interface {
>   ReadWrite
>   Lock
>   Close()
>}
> ```
> ## 类型断言：
> > 一个接口的值是由一个具体类型和具体类型的值两部分组成  
> > 这两部分分别称为接口的动态类型和动态值
> ### 类型断言语法：
> > 转换为类型断言的值, 断言是否成功的bool值 := 变量.(断言的类型)









