# 番外：
> 相比于Go语言宣扬的“用通讯的方式共享数据”，  
> 通过共享数据的方式来传递信息和协调线程运行的做法其实更加主流  
> 毕竟大多数现代编程语言都是用后一种方式作为并发编程的解决方案的  
---

.  
# 数据一致性：
## 竞态条件：
> 一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况  
> 这种情况被称为竟态条件，这往往会破坏共享数据的一致性  
## 共享数据的一致性：
> 共享数据的一致性代表着某种约定  
> 即多个线程对共享数据的操作总是可以达到它们各自预期的效果  
> 若一致性得不到保证，则会影响到一些线程中代码和流程的正确执行  
> 甚至造成某种不可预知的错误
## 解决方案
> 一个线程在想要访问某个共享资源的时候，需要先申请对该资源的访问权限  
> 并且只在申请成功后，访问才能真正开始  
> 当线程对共享资源的访问结束时，还必须归还对该资源的访问权限  
## 相关临界区：
> 如果针对同一个共享资源，这样的代码片段有多个  
> 那么它们就可以被称为相关临界区  
> 临界区总是需要受到保护的，否则会产生竟态条件  
---

.  
# mutex(互斥锁):
## 简介：
> go语言中有许多同步工具  
> 但最常用的同步工具当属互斥量(mutex)  
> sync包中的Mutex就是与其对应的类型
## 作用：
> 一个互斥锁可以用来保护一个临界区或者一组相关临界区  
> 我们可以通过它来保证，同一时刻只有一个goroutine处于该临界区内  
## 使用互斥锁的注意事项：
1. 不要重复锁定互斥锁
2. 不要忘记解锁互斥锁，必要时使用defer语句  
3. 不要对尚未锁定或已解锁的互斥锁解锁  
4. 不要在多个函数之间直接传递互斥锁  
## 切记：
> 一个互斥锁只能用来保护一个临界区  
> (不要用同一个互斥锁保护多个无关临界区，否则会有更多goroutine争夺该锁  
> 会让程序变慢，还会增大死锁的可能性)  
## 示例：
```go
// 为保证每个goroutine内的mutex是同一个，使用应该用指针传参
func test(mu *sync.Mutex, num *int) {
	/*
	mu.Lock()			// 每当有goroutine进入临界区，需要先进行锁定
	defer mu.Unlock()	// goroutine离开连接区时，要及时解锁
	*/
	for i:=0; i<100000; i++ {
		*num++
	}
	fmt.Println("ok")
}

func main() {
	mu := new(sync.Mutex)
	num := 0
	go test(mu, &num)
	go test(mu, &num)
	time.Sleep(time.Second*2)
	fmt.Println(num)
}
```
---

.  
# RWMutex(读写锁)：
## 简介：
> 读写锁是需写互斥锁的简称  
> Go中的读写锁由sync.RWMutex类型的值代表  
> 读写锁是把对共享资源的读操作和写操作区别对待了  
> 它可以对这两种操作施加不同程度的保护  
> 相比于互斥锁，读写锁可以实现更加细腻的访问控制  
## 相关方法：
> Lock      对写锁进行加锁
> Unlock    对写锁进行解锁
> RLock     对读锁进行加锁
> RUnlock   对读锁进行解锁
## 对同一个读写锁有如下规则：
1. 在写锁已经被锁定的情况下，若再试图锁定写锁或读锁，都会阻塞当前goroutine
2. 在读锁已经被锁定的情况下，可以继续锁定读锁
3. 在读锁已经被锁定的情况下，若再试图锁定写锁，会阻塞当前goroutine
---

.  
# sync.Map(并发安全字典):
## 简介：
> Go自带的字典类型map并不是并发安全的  
> (即同时让不同goroutine对同一字典读写是不安全的)
> sync.Map提供了一些常用的键值存取操作方法，并保证了这些操作的并发安全  
> 并且它的存、取、删除等方法的时间复杂度都是O(1)
## 优点：
> 与单纯使用原生Map加互斥锁的方案相比，sync.Map可以显著减少锁的争用  
> sync.Map虽然也用到锁，但它在尽可能的避免使用锁  
## 注意：
> 与原生map相比，sync.Map只是Go语言标准库中的一员  
> 所以Go语言的编译器并不会对它的键和值进行特殊的类型检查  
> (所有方法的键和值类型都是interface{})  
> 所以必须在程序中自行保证它的键类型和值类型的正确性  
## 键类型的要求：
> 键的实际类型不能是函数类型、字典类型、切片类型  
## 方法：
1. Store(key, value)  
   往字典里添加元素  
2. Load(key)
   从字典里获取元素(返回value以及成功与否)  
3. LoadOrStory(key, value)
   若该key有对应value，则返回value和true  
   若该无key对应value，则往字典添加该元素并返回value和False  
4. Delete(key)
   删除key对应的元素  
5. Range(func(k, v interface{}) bool{...})   
   遍历字典  
---