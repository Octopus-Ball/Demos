# 番外：
> http是一个无状态协议  
> 即一次请求和上一次请求没有任何关联  
> 这种无状态的好处是快速，坏处是要想关联它的几次请求需要特殊手段  
---

# cookie和session：
> ## 简介：
> > 目前大多数会话保持是使用Session + Cookie  
> > 但是理论上单使用session或单使用cookie都可以保持会话状态  
> ## cookie+session的流程：
> 1. C发送一个http请求到S
> 2. S接收请求后建立一个session
> 3. S发送http响应给C，响应中包含cookie，cookie中有相应sessionID
> 4. 当C再次发起请求时，若C有相应cookie，会在请求头中携带cookie
> 5. S端收到cookie后解析并关联session即可得知请求发起者的身份
> ## 实现session的其他方法：
> cookie只是实现session的其中一种方案  
> 禁用cookie后还有其他方法，比如放到url中  
---

# token：
> ## 简介：
> > token也称为令牌  
> > token的认证方式类似于临时证书签名，是一种服务端无状态的认证方式  
> > (所谓无状态就是服务端不会保存身份认证相关的数据)
> > 非常适合于REST API的场景  
> ## 组成：
> 1. uid：用户唯一身份标识
> 2. time：当前时间的时间戳
> 3. sign：签名(使用hash/encrypt压缩成定长的十六进制字符串，以防恶意篡改)
> 4. 固定参数(可选)：将一些常用的固定参数加入到token中是为了避免重复查库
> ## 存放：
> > token在客户端一般存放于localStorage、cookie或sessionStorage中  
> > 在服务端一般存放于数据库中  
> ## token认证流程:
> 1. 用户登陆成功后，服务器返回Token给客户端
> 2. 客户端收到数据后，进行保存
> 3. 当客户端再次访问服务端时，将token放入header中
> 4. 服务端进行校验，校验成功返回请求数据，校验失败则返回错误码
> ## 抵抗CSRF：
> > token可以抵抗CSRF，cookie+session不行  
---

# 分布式情况下的session和token：
## 分布式状态下的session：
> session是有状态的，一般存于服务器内存或硬盘中  
> 当服务器采用分布式或集群时，session就会面对负载均衡问题  
> 负载均衡多服务器的情况下，不好确认当前用户是否登陆，因为服务器不共享session  
> 该问题可以通过将session统一存在一个服务器中来解决(但这样就不能完全达到负载均衡的效果)
## 分布式状态下的token：
> token是无状态的，token字符串里保存了所有的用户信息  
> 客户端登陆传递信息给服务端，服务端收到后把用户信息加密(token)传给客户端  
> 客户端将token存放于localStoage等容器中  
> 客户端每次访问都传递token，服务端解密token就知道这个用户是谁了  
> 通过cpu加减密，服务端就不需要存储session占用存储空间  
> 就可以很好的解决负载均衡多服务器的问题了  
> 这个方法叫做JWT  
---

# JWT(JSON Web Token):
## 单点登陆需求：
> 站点A和站点B提供同一公司的相关服务  
> 现要求只需用户登陆其中一个网站，然后他就会自动登陆到另一个网站  
## 解决方案：
> 1. 通过持久化session数据  
> 服务端收到请求后，验证服务从持久层请求数据  
> 该方案优点是架构清晰，缺点是架构修改比较费劲  
> 会有单点风险，若持久层失败，整个系统就会挂掉  
> 2. JWT方案(通过客户端保存会话数据，而服务端不保存数据)  
## JWT的原则：
> 在服务端进行身份验证后，将生成一个JSON对象并发送回用户  
> 之后，当用户与服务器通信时，客户端在请求中发回JSON对象  
> 服务端仅依赖于这个JSON对象来标识用户  
> 为了防止用户篡改数据，服务器将在生成对象时添加签名  
## JWT的数据结构:
> JWT分为三部分：JWT头、有效载荷、签名  
> 三部分通过 “.” 分隔，连成一个很长的字符串  
> JWT头是描述JWT元数据的JSON对象(包含签名算法、令牌类型)  
> 有效载荷是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据  
> 签名是对上面两部分数据的签名，通过指定算法生成哈希，以确保数据不会被篡改  
## 跨域：
> 客户端接收到服务端返回的JWT  
> 若存在Cookie中，就可以自动发送，但是不会跨域  
> 因此一般是将它放入HTTP请求的Header Authorization字段中，  
> 或POST请求的数据主体中  
---

# JWT优缺点：
## 优点：
> ### 1.无状态：
> > token自身包含了身份验证所需要的所有信息  
> > 使得服务端不再需要存储session信息  
> > 这显然增加了系统的可以性和伸缩性，减轻了服务端压力  
> ### 2.有效避免CSRF攻击：
> > 跨站请求伪造  
> > Session认证中Cookie中的session_id是由浏览器发送到服务端的  
> > 借助这个特性，攻击者就可以通过让用户误点击攻击链接，达到攻击效果  
> > 而若使用token，客户端获取token后一般存于local storage中  
> > 然后前端通过某些方式给每个发到后端的请求加上这个token  
> > 这样就不会出现CSRF漏洞问题
> > (但是这会增加XSS攻击中被盗的风险)
> ### 3.适合移动端应用：
> > 使用session进行身份验证会需要保存一份信息在服务端  
> > 该方式会依赖到Cookie，所以不适合移动端  
> > 但是token不会存在该问题，因为只要token可以被客户端存储就能使用  
> ### 4.单点登陆友好：
> > 若使用session进行身份认证，要实现单点登陆，  
> > 就需要把用户的Session信息存储在同一台电脑上  
> > 并且还会遇到Cookie跨域的问题  
> > 但是，使用token进行1认证的话，token被保存在客户端，不会存在这些问题  
## 问题及解决方案：
> ### 1.注销登陆等场景下token还有效  
> > 与之类似的场景还有：退出登陆、修改密码、  
> > 服务端修改了某个用户具有的权限或角色、用户账户被删除/暂停  
> > 该问题不会存在于session认证中，因为面对该情况服务端删除session即可  
> > 但是token认证的方式就不好解决了  
> > token一旦派发出去，若后端不增加其他逻辑，那么token在失效之前都是有效的  
> > `解决方案：`  
> > `1.黑名单机制：`  
> > `服务端维护一个黑名单，若让某token失效，就加入黑名单`  
> > `每次使用token都先检查是否在黑名单中`  
> > `2.保持令牌有效期短并经常轮换`  
> > `方式简单，但会导致用户登陆状态不会被持久记录，而且需要用户经常登陆`  
> ### 2.token的续签问题：
> > token有效期不建议设置太长  
> > 那么token过期后如何认证，如何实现动态刷新token，以避免用户经常需要重新登陆  
> > `解决方案：`  
> > `1.快到期更新(类似于session中的做法)`  
> > `假设服务端给token有效期设置为30分钟，服务端每次进行校验时，`  
> > `若发现token快过期，则马上重新生成token给客户端`  
> > `客户端每次请求都检查新旧token，若不一致，则更新本地token`  
> > `该做法问题在于仅在快过期时才会更新token，对客户端不是很友好`  
> > `2.每次请求都返回新token`  
> > `该方案思路很简单，但是很明显开销会比较大`  
> > `3.token有效设置到半夜`  
> > `保证大部分用户白天可以正常登陆`  
> > `适用于对安全性要求不高的系统`  
> > `4.用户登陆返回两个token`  
> > `短期的token用于请求资源，长期的token用于刷新token`  
> > `若短期token失效，则客户端携带长期token去刷新token`  
---