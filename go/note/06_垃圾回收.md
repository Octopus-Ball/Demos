# 经典的GC算法：
## 1.引用计数:
> ### 过程：
> > 对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1  
> > 当引用计数器为0时，回收对象
> ### 优点：
> 1. 简单(一旦引用计数为0,内存直接释放)
> 2. 将内存回收时间分摊到了平时，不会等内存达到某个阈值时才回收
> ### 缺点：
> 1. 无法解决循环引用的问题
> 2. 消耗资源(需要对每个对象维护引用计数)
> 3. 操作变复杂，对象变更时需要更改计数，有时还需要释放对象

## 2.标记-清除:
> ### 过程：
> > 该算法主要分为两步：标记(Mark phase)和 清除(Sweep phase)  
> > 第一步：从根变量开始遍历所有引用的和未引用的对象，并进行标记  
> > 第二步：回收标记为未引用的对象  
> ### 优点：
> > 解决了引用计数的缺点
> ### 缺点：
> 1. 该算法在执行的时候需要程序暂停，程序会出现卡顿
> 2. 标记过程需要扫描整个heap(堆)
> 3. 清除数据会产生heap碎片
> ### 为何会卡顿：
> 标记清除算法在扫描对象前需要runtime把所有的线程全部冻结  
> 这样所有对象都不会被修改了，此时去扫描就是绝对安全的  
> 但是会造成卡顿问题
  
## 3.分代收集:
> ### 过程：
> > 按照对象生命周期长短划分不同代的空间  
> > 生命周期长的放入老年代，短的放入新生代  
> > 不同代有不同的回收算法和回收频率  
> ### 优点：
> > 回收性能好
> ### 缺点：
> > 算法复杂
---

# Go的GC算法：
## 简介：
> Go的GC算法主要是基于标记清除，并在此基础上做了改进，形成独特的三色标记法  
> 这是一种并发的标记清除回收器  
> 它对停顿时间进行了改进，(但这是以牺牲GC其他方面的特性为代价的)
> 目前Go的回收器并不是分代的，它在后台运行的仍然是老旧的标记清除回收器
## 三色标记含义：
1. 灰色：该对象已被标记，但该对象的子对象未标记
2. 黑色：该对象已被标记，且该对象的子对象也已被标记
3. 白色：该对象未被标记
## 三色标记法的流程：
1. 将程序创建的对象都标记为白色
2. gc开启写屏障，并开始扫描所有可达对象，将其标记为灰色
3. 从灰色对象中找到其引用的对象，将其标记为灰色后，再把本对象改为黑色
4. 写屏障监视对象的内存修改，并重新标色，直到灰色对象不存在
5. 此时gc回收白色对象
## 特点：
> 1.GO的GC是并行GC(GC大部分处理和普通go代码是同时运行的)
> 2.不是分代的，这样的好处是  
> 它的停顿时间非常短,不过其他方面会变糟糕  
> 比如每次GC需要做很多工作，会抢占CPU时间,拖慢程序   
> 
## GO如何处理标记清除的卡顿问题：
> 如果是STW的，那么三色标记没有问题  
> 因为在STW中，一个对象，只有它引用的对象全部被标记后，它才会被标记为黑色  
> 所以黑色对象要么引用黑色对象，要么引用灰色对象，不会出现黑色引用白色对象  
> 
> 但是对于垃圾回收和用户代码并行的场景  
> 用户代码可能会修改已经标记为黑色的对象，让它引用白色对象  
> 但该白色对象没有机会被重新标记，会被当作垃圾回收掉  
>
> 为解决该问题，我们引入 "写屏障(write barrier)" 机制  
> 1.若一个黑色对象引用了曾经标记的白色对象，则写屏障被触发，GC会重新扫描该对象，并将其标为灰色  
> 2.将过程中新生成的对象一律都标记为灰色  
---