# 消息中间件的作用：
## 1.解耦消息的生成和消费
## 2.缓冲
---

# 消息队列的通信模式:
## 点对点模式(queue):
> 生产者生产消息，并发送到queue中  
> 消费者从queue中取出消息进行消费  
> 消息被消费后，queue中就不存在该消息了，不存在重复消费问题  
## 发布/订阅(topic):
> 发布者将消息发布到topic中  
> 多个订阅者消费该消息  
> 发布到topic的消息会被所有订阅者消费  
## 分组订阅：
> 当发布者发布量很大时，会存在订阅者处理能力不足的问题  
> 所有可以由多个订阅者节点组成一个订阅组来负载均衡消费topic消息  
> 这样很容易实现消费能力线性扩展  
> 可以看成一个订阅组里又以点对点的形式消费  
---

# RabbitMQ特点：
## 可靠性：
> 持久化、传输确认、发布确认  
## 可扩展性：
> 多个节点可以组成一个集群，可动态更改  
## 多语言客户端：
> 几乎支持所有常用语言  
## 管理界面：
> 易用的用户界面，便于监控和管理  
---

# 安装配置：
## 安装：
> 、、、、、、
## 配置:
> ### 添加用户:
> > rabbitmqctl add_user 用户名 密码
> > (默认用户名guest,密码guest只限本地访问)
> ### 设置用户角色：
> > rabbitmqctl set_user_tags 用户名 administrator
> ### 设置权限：
> > rabbitmqctl set_permissions -p / 用户名 ".*" ".*" ".*"
---

# RabbitMQ工作原理：
## 相关角色：
> ### Publisher(发布者)
> ### Consumer(消费者)
> ### Exchange(交换机)
> > 消息交换机，决定消息按什么规则，路由到哪个队列  
> ### Queue(队列)
> > 消息载体，每个消息都会被投到一个或多个队列  
## 消息发送流程：
1. 发布者(publishers)将消息(message)发送给交换机(exchange)
2. 交换机将消息根据路由规则分发给绑定的队列(queue)
3. AMQP代理将消息投递给订阅了此队列的消费者  
## 其他关键术语:
> ### Binding
> > 绑定，把exchange和queue按照路由规则绑定起来  
> ### Routing Key
> > 路由关键字,exchange根据该关键字来投递消息  
> ### Channel
> > 消息通道，客户端的每个连接建立多个channel  
---

# 交换机(Exchanges):
## 简介：
> RabbitMQ消息模型的核心理念是  
> 发布者不会直接发送任何消息给队列  
> 发布者只把消息发送给一个交换机  
> 交换机必须知道如何处理它接收到的消息  
> (推送到指定的一个队列还是多个，或直接忽略该消息)  
> 这些消息是通过交换机类型(echange type)来定义的  
## 交换机类型：
> ### 直连交换机(Direct)：
> > 类似单播，RoutingKey和BindingKey完全匹配
> ### 扇型交换机(Fanout)：
> > 类似广播，转发到所有绑定交换机的Queue
> ### 主题交换机(Topic)：
> > 类似组播，转发到符合通配符匹配的Queue
> ### 头交换机(Headers)：
> > 请求头与消息头匹配，才能接收消息
---

# 信道(Channel):
> 在使用RabbitMQ时，不管是消费还是生产都需要创建信道(Channel)  
> 为什么不直接使用Connection，而要引入信道呢  
> 因为如果应用有多个线程读写RabbitMQ，建立多个Connection，就对应多个TCP连接  
> 而对于操作系统而言，建立和销毁TCP连接是很昂贵的开销  
> 所以RabbitMQ采用Channel复用了Connection的TCP的连接，同时它又能确保每个线程的私密性  
> Channel实质上是屏蔽了Connection的细节，让开发者不用去管TCP层面的事情  
---

# 如何保证消息不被重复消费(消息的幂等性)：
## 问题简介：
> RabbitMQ、RocketMQ、Kafka都可能出现消息重复消费的问题  
> 因为这样的问题不是MQ自己保证的，是由开发来保证的
## 出现问题的原因：
> 若消费者消费了某些信息，在提交被消费标记前服务宕机了  
> 那么当服务恢复以后就认为之前那些消息未被消费而重复投递  
> 此时若消费者没有去重的话，就会出现重复消费问题  
## 幂等性：
> 一个数据或一个请求，不论被重复多少次  
> 但是得确保对应的数据是不会被改变的，不能出错  
## 如何保证幂等性：
> 重复消费不可怕，可怕的是没有考虑重复消费后如何保证幂等性  
> 若客户端是要拿数据写入数据库，可以根据主键查询一下，若有该数据，则不再写入  
> 若是写Redis，则不需要额外处理，反正每次都是set，天然幂等  










# AMQP协议：
## 简介：
> AMQP(高级消息队列协议)是一个应用层网络协议  
> 它支持符合要求的客户端应用和消息中间件代理之间进行通信  
> 由于AMQP是一个网络协议，所以该过程中的发布者、消费者、消息代理可以存在不同设备上  
## 消息确认：
> 当一个消息从队列中投递给消费者后  
> 消费者会通知消息代理(该操作可以是自动的也可由开发者执行)  
> 当消息确认被启动的时候，直到消息代理收到来自消费者的确认回执，才会将消息从队列删除  
---