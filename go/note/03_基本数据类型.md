# 数值类型:
## 整数：
> ### 有符号整数：
> int8、int16、int32、int64
> ### 无符号整数：
> uint8、uint16、uint32、uint64
## 浮点数：
> float32、float64
## 复数：
> complex64、complex28
## 其他数字类型：
> byte -----字节类型，类似于uint8(1字节8位)  
> rune -----字符类型，(类似于int32)  
> uint -----32或64位  
> uintptr -----无符号整型(用来存放指针)  
---
.   

# 布尔类型:
> 取值只能是常量True或False
---
.  

# 字符串类型：
## 简介：
> 字符串是一种值类型，且值不可变(其实就是定长的字节数组)
## 操作：
```go
// 定义字符串
// 可使用""来定义字符串(字符串字面量)
// 这种双引号字面量不能跨行
var str = "hello go 语言"
// 用``来定义多行字符串
// 俩个反引号间的字符串将被原样赋值到str变量中
// 反引号间的换行也将被作为字符串中的换行
// 其中的所有转义字符无效
var str = `
    123
    456
`


// 转意字符
// 可使用转意字符实现换行、缩进等效果
/*
    \n  换行符号
    \r  回车符号
    \t  tab键
    \\  反斜杠自身
*/


// 比较运算
// 可对字符串进行比较运算(==、!=、<、<=、>=、>）


// 获取字符串所占字节的长度
len("abc")      // 3
len("你好")     // 6


// 获取实际字符长度
utf8.RuneCountlnString("你好abc")   // 5
len([]rune("你好abc"))  // 5    (转成rune数组，再求长度)


// 字符串拼接
str := "abc" + "def"
str1 += "the end"

// 字符串截取
// 可以通过切片的形式截取一个数组或字符串
str1 := "abcde"
rst1 := string([]byte(str1)[1:3])// 若不包含中文，可以byte切片处理
str2 := "你好abc"
rst2 := string([]rune(str2)[1:3])// 若包含中文，则以rune切片处理

// 字符串替换
rst := strings.Replace(原字符串, 要替换字符, 替换为, 替换个数)
```
---

.  
# 字符类型：
## byte类型：
> byte类型类似于uint8类型，它代表了ASCII码的一个字符

## rune类型：
> rune是Go语言中一种特殊的数据类型，代表utf-8字符  
> rune相当于go的char
> 它是int32的别名，几乎在所有方面等同于int32
> 需要处理中文、日文或其他复合文字时，需要用到
---

.  
# nil(空值、零值):
> ## 简介：
> > Go中，布尔类型的零值为false；数值类型的零值为0；字符串类型的零值为""  
> > 而指针、map、channel、函数、接口 的零值为nil  
> > nil是Go中预定义好的标识符
> ## 注意：
> 1. nil标识符是不能比较的
> fmt.Println(nil == nil)   // 会报错
> 2. nil不是关键字或保留字
> 3. nil没有默认类型
> 4. 不同类型的nil值占用的内存大小可能是不一样的

.  
# 容器类型：
## 数组：
> ### 简介：
> 1. 数组定义了长度和数据类型，数组的长度是数据类型的一部分
> 2. 数组不需要显式的初始化，数组的零值是可以直接使用的(元素会自动初始化为对应类型的零值)
> ### 定义方式：
> ```go
> // 数组类型的写法
> [数组长度]元素类型
> 
> // 定义数组
> var 数组名 数组类型
> 数组名 := 数组类型
> var arr1 [5]int
> arr2 := [3]int{1, 2, 3} // 定义同时赋值可省略var
> arr3 := [...]int{1, 2, 3} // 定义同时赋值可省略数组长度
>
> // 定义二维数组
> var 数组名 [行数][列数]数据类型
> var arr1 [2][3]int
> arr2 := [...][2]int{{1, 2}, {3, 4}}
> ```
> ### 遍历数组：
> ```go
> arr := [5]int{1, 2, 3, 4, 5}
> // 用下标遍历
> for i := 0; i < len(arr); i++ {
>   fmt.Println(arr[i])
> }
> // 用range遍历
> for index, value := range arr {
>   fmt.Println(index)  // 元素下标
>   fmt.Println(value)  // 元素值
> }
> ```
## 切片：
> ### 简介：
> > 切片是在数组之上的抽象数据类型，是一个引用类型  
> > 切片基于数组构建，但提供更强劲的功能和遍历  
> > 切片类型没有给定固定的长度  
> > 一个切片是一个数组片段的描述(包含指向数组的指针、切片长度、切片容量(即切片的最大容量))  
> ### 数据结构：
> ```go
> type slice struct {
>   ptr *[...]int       // 指向数组的指针
>   len int             // 切片的长度
>   cap int             // 切片的容量
> }
>
> // 获取切片长度
> l := len(s)
> // 获取切片容量
> c := cap(s)
> ```
> ### 特性：
> 1. 切片是一种引用类型，其赋值和传参操作，都是传递对其的引用
> 2. 切片增长不能超过其容量，超出容量会导致运行时异常
> ### 定义切片：
> ```go
> // 该方法定义切片后还不能直接使用，因为本身是一个空
> var s1 []int
> 
> // 定义并赋初值，或用make初始化后的切片，已经分配空间，可直接使用
> s2 := []int{1, 2, 3}
> s3 := make([]int, 长度, 容量)
>
> // 声明一个二维切片
> s4 := [][]类型{
>   {11, 12, 13},
>   {21, 22, 23},
> }
> s5 := make([][]int, 5, 10)
>
> // 利用已有数组生成一个切片
> arr := [5]int{1,2,3,4,5}
> s := arr[1:3]
> ```
> ### 切片操作:
> ```go
> // 在切片后追加元素
> // append方法返回一个追加元素后的新切片，并保持原切片不被改动
> // 若append追加后未突破原切片容量，则俩个切片皆对应原数组
> // 若追加数据后突破了原切片容量，则返回的新切片是基于新数组的引用
> new_s := append(s, 元素1, 元素2 ...)
> new_s := append(s, 切片)
>
> // 拷贝切片
> copy(s1, s2)  // 切片s2内元素拷贝到s1内(若s1长度不够则只拷贝部分)
> ```
> ### 番外：
> 可对切片继续进行切片操作  
> 对切片再切片时，结尾下标可在不超过原切片容量的情况下超过原切片长度


## map：
> ### 简介：
> > 引用类型  
> > map使用hash表  
> > 除了slice、map、function的内建类型，其他类型几乎都可以作为map的key
> ### 定义Map：
> ```go
> // 定义并赋初值
> m := map[key数据类型]value数据类型 {
>   key1: value1,
>   key2: value2,
> }
>
> // 使用make函数定义
> m2 := make(map[key数据类型]value数据类型)
>
> // 声明map变量
> // 该方法未分配内存，变量不可直接使用
> var m3 map[key数据类型]value数据类型
> ```
> ### 操作Map：
> ```go
> // 根据key获取value
> value := m[key]
> // 若key不存在，则value为对应类型零值,ok为false
> // 若key存在，则value为对应值，ok为true
> value, ok := m[key]
>
> // 获取Map长度
> len(m)
>
> // 向map内添加新元素
> m[new_key] = new_value
>
> // 删除map内某元素
> delete(m, key)
>
> // 遍历Map
> for k, v := range m {
>   fmt.Println(k)
>   fmt.Println(v)
> }
> ```
## 链表：
> ### 简介：
> > Go语言中链表使用container/list包来实现，其实现原理是双链表  
> > 链表能够高效的进行任意位置的元素的插入和删除操作
> ```go
> import "container/list"
> // 初始化链表
> l := list.New()
> // 尾插链表(返回插入的节点)
> node := l.PushBack(元素)
> // 头插链表(返回插入的节点)
> node :=l.PushFront(元素)
> // 获取链表的头节点
> node := l.Front()
> // 获取链表的尾节点
> node := l.Back()
> // 删除节点
> l.Remove(node)
> // 获取链表长度
> L := l.Len()
> // 遍历链表
> for node := l.Front(); i != nil; i = i.Next() {
>   fmt.Println(node.Value)
> }
> ```

.  
# make和new关键字：
> ## 简介：
> > new和make是两个内置函数，用来创建并分配内存  
> > new用来分配内存  
> > make用于slice、map、channel的初始化
> ## 使用new函数分配内存空间：
> > new方法分配对应类型内存，并返回一个指向该类型内存地址的指针
> ```go
> // new函数为内置数据类型分配内存
> num_p := new(int)
> // 相当于
> var num int
> num_p := &num
>
> // new函数为自定义类型分配内存
> type Student struct{
>   name string
>   age int
> }
> s_p := new(Student)
> ```
> ## 使用make函数分配内存：
> > make也是用于分配内存的，但是和new不同  
> > 它用于channel、map、slice的内存创建，并返回该类型本身
> > (因为这些类型本身就是引用类型)
